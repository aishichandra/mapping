
<!-- Generated by ai2html v0.111.0 - 2022-08-03 12:43 -->
<!-- ai file: map1.ai -->
<style media="screen,print">
	#g-map1-box ,
	#g-map1-box .g-artboard {
		margin:0 auto;
	}
	#g-map1-box p {
		margin:0;
	}
	#g-map1-box .g-aiAbs {
		position:absolute;
	}
	#g-map1-box .g-aiImg {
		position:absolute;
		top:0;
		display:block;
		width:100% !important;
	}
	#g-map1-box .g-aiSymbol {
		position: absolute;
		box-sizing: border-box;
	}
	#g-map1-box .g-aiPointText p { white-space: nowrap; }
	#g-map1-Artboard_1 {
		position:relative;
		overflow:hidden;
	}

</style>

<div id="g-map1-box" class="ai2html ai2html-responsive">

	<!-- Artboard: Artboard_1 -->
	<div id="g-map1-Artboard_1" class="g-artboard" style="max-width: 2832px;max-height: 2133px" data-aspect-ratio="1.328" data-min-width="0">
	<div style="padding: 0 0 75.3281% 0;"></div>
		<img id="g-map1-Artboard_1-img" class="g-map1-Artboard_1-img g-aiImg" alt="" src="map1-Artboard_1.jpg"/>
		<!-- Generator: Adobe Illustrator 25.4.1, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
		<svg class="g-map1-Artboard_1-interactions-img g-aiImg" version="1.2" baseProfile="tiny" id="g-map1-Artboard_1-interactions-img" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
			x="0px" y="0px" viewBox="0 0 2832 2133.292" overflow="visible" xml:space="preserve">
		<g>
			
			<radialGradient id="myGradient" style="opacity:0.75;" cx="1625.5393" cy="1068.2809" r="117.0574" gradientUnits="userSpaceOnUse">
				<stop  offset="0" style="stop-color:#FCEEBE"/>
				<stop  offset="0.1182" style="stop-color:#F7E9BB;stop-opacity:0.8818"/>
				<stop  offset="0.2587" style="stop-color:#E9DCB0;stop-opacity:0.7413"/>
				<stop  offset="0.4106" style="stop-color:#D1C6A0;stop-opacity:0.5894"/>
				<stop  offset="0.5707" style="stop-color:#AFA688;stop-opacity:0.4293"/>
				<stop  offset="0.7371" style="stop-color:#847E6A;stop-opacity:0.2629"/>
				<stop  offset="0.9062" style="stop-color:#504E46;stop-opacity:0.0938"/>
				<stop  offset="1" style="stop-color:#303030;stop-opacity:0"/>
			</radialGradient>
			
				<circle style="opacity:0.75;" fill="url('#myGradient')" stroke="#FCEEBE" stroke-miterlimit="10" cx="1625.539" cy="1068.281" r="117.057"/>
		</g>
		<style>
		#g-map1-Artboard_1-interactions-img rect, #g-map1-Artboard_1-interactions-img circle, #g-map1-Artboard_1-interactions-img path, #g-map1-Artboard_1-interactions-img line, #g-map1-Artboard_1-interactions-img polyline, #g-map1-Artboard_1-interactions-img polygon { vector-effect: non-scaling-stroke; }
		</style>
		</svg>

	</div>

</div>

<script type="text/javascript">
	(function (containerId, opts) {
			var nameSpace = opts.namespace || '';
			var containers = findContainers(containerId);
			containers.forEach(resize);

			function resize(container) {
				var onResize = throttle(update, 200);
				var waiting = !!window.IntersectionObserver;
				var observer;
				update();

				document.addEventListener('DOMContentLoaded', update);
				window.addEventListener('resize', onResize);

				// NYT Scoop-specific code
				if (opts.setup) {
					opts.setup(container).on('cleanup', cleanup);
				}

				function cleanup() {
					document.removeEventListener('DOMContentLoaded', update);
					window.removeEventListener('resize', onResize);
					if (observer) observer.disconnect();
				}

				function update() {
					var artboards = selectChildren('.' + nameSpace + 'artboard[data-min-width]', container),
						width = Math.round(container.getBoundingClientRect().width);

					// Set artboard visibility based on container width
					artboards.forEach(function (el) {
						var minwidth = el.getAttribute('data-min-width'),
							maxwidth = el.getAttribute('data-max-width');
						if (+minwidth <= width && (+maxwidth >= width || maxwidth === null)) {
							if (!waiting) {
								selectChildren('.' + nameSpace + 'aiImg', el).forEach(updateImgSrc);
							}
							el.style.display = 'block';
						} else {
							el.style.display = 'none';
						}
					});

					// Initialize lazy loading on first call
					if (waiting && !observer) {
						if (elementInView(container)) {
							waiting = false;
							update();
						} else {
							observer = new IntersectionObserver(onIntersectionChange, {});
							observer.observe(container);
						}
					}
				}

				function onIntersectionChange(entries) {
					// There may be multiple entries relating to the same container
					// (captured at different times)
					var isIntersecting = entries.reduce(function (memo, entry) {
						return memo || entry.isIntersecting;
					}, false);
					if (isIntersecting) {
						waiting = false;
						// update: don't remove -- we need the observer to trigger an update
						// when a hidden map becomes visible after user interaction
						// (e.g. when an accordion menu or tab opens)
						// observer.disconnect();
						// observer = null;
						update();
					}
				}
			}

			function findContainers(id) {
				// support duplicate ids on the page
				return selectChildren('.ai2html-responsive', document).filter(function (el) {
					if (el.getAttribute('id') != id) return false;
					if (el.classList.contains('ai2html-resizer')) return false;
					el.classList.add('ai2html-resizer');
					return true;
				});
			}

			// Replace blank placeholder image with actual image
			function updateImgSrc(img) {
				var src = img.getAttribute('data-src');
				if (src && img.getAttribute('src') != src) {
					img.setAttribute('src', src);
				}
			}

			function elementInView(el) {
				var bounds = el.getBoundingClientRect();
				return bounds.top < window.innerHeight && bounds.bottom > 0;
			}

			function selectChildren(selector, parent) {
				return parent ? Array.prototype.slice.call(parent.querySelectorAll(selector)) : [];
			}

			// based on underscore.js
			function throttle(func, wait) {
				var timeout = null, previous = 0;
				function run() {
					previous = Date.now();
					timeout = null;
					func();
				}
				return function () {
					var remaining = wait - (Date.now() - previous);
					if (remaining <= 0 || remaining > wait) {
						clearTimeout(timeout);
						run();
					} else if (!timeout) {
						timeout = setTimeout(run, remaining);
					}
				};
			}
		})("g-map1-box", {namespace: "g-", setup: window.setupInteractive || window.getComponent});
</script>
<!-- End ai2html - 2022-08-03 12:43 -->
