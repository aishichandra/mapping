
		<!-- Generated by ai2html v0.111.0 - 2022-08-03 00:42 -->
		<!-- ai file: map1.ai -->
		<style media="screen,print">
			#g-map1-box ,
			#g-map1-box .g-artboard {
				margin:0 auto;
			}
			#g-map1-box p {
				margin:0;
			}
			#g-map1-box .g-aiAbs {
				position:absolute;
			}
			#g-map1-box .g-aiImg {
				position:absolute;
				top:0;
				display:block;
				width:100% !important;
			}
			#g-map1-box .g-aiSymbol {
				position: absolute;
				box-sizing: border-box;
			}
			#g-map1-box .g-aiPointText p { white-space: nowrap; }
			#g-map1-Artboard_1 {
				position:relative;
				overflow:hidden;
			}

		</style>

		<div id="g-map1-box" class="ai2html ai2html-responsive">

			<!-- Artboard: Artboard_1 -->
			<div id="g-map1-Artboard_1" class="g-artboard" style="max-width: 2832px;max-height: 2133px" data-aspect-ratio="1.328" data-min-width="0">
		<div style="padding: 0 0 75.3281% 0;"></div>
				<img id="g-map1-Artboard_1-img" class="g-map1-Artboard_1-img g-aiImg" alt="" src="ai2html-output\map1-Artboard_1.jpg"/>
		<!-- Generator: Adobe Illustrator 25.4.1, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
		<svg class="g-map1-Artboard_1-interactions-img g-aiImg" version="1.2" baseProfile="tiny" id="g-map1-Artboard_1-interactions-img" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
			x="0px" y="0px" viewBox="0 0 2832 2133.292" overflow="visible" xml:space="preserve">
		<g>
			
		</g>
		<style>
		#g-map1-Artboard_1-interactions-img rect, #g-map1-Artboard_1-interactions-img circle, #g-map1-Artboard_1-interactions-img path, #g-map1-Artboard_1-interactions-img line, #g-map1-Artboard_1-interactions-img polyline, #g-map1-Artboard_1-interactions-img polygon { vector-effect: non-scaling-stroke; }
		</style>
		</svg>

			</div>

		</div>

		<script type="text/javascript">
			(function (containerId, opts) {
					var nameSpace = opts.namespace || '';
					var containers = findContainers(containerId);
					containers.forEach(resize);

					function resize(container) {
						var onResize = throttle(update, 200);
						var waiting = !!window.IntersectionObserver;
						var observer;
						update();

						document.addEventListener('DOMContentLoaded', update);
						window.addEventListener('resize', onResize);

						// NYT Scoop-specific code
						if (opts.setup) {
							opts.setup(container).on('cleanup', cleanup);
						}

						function cleanup() {
							document.removeEventListener('DOMContentLoaded', update);
							window.removeEventListener('resize', onResize);
							if (observer) observer.disconnect();
						}

						function update() {
							var artboards = selectChildren('.' + nameSpace + 'artboard[data-min-width]', container),
								width = Math.round(container.getBoundingClientRect().width);

							// Set artboard visibility based on container width
							artboards.forEach(function (el) {
								var minwidth = el.getAttribute('data-min-width'),
									maxwidth = el.getAttribute('data-max-width');
								if (+minwidth <= width && (+maxwidth >= width || maxwidth === null)) {
									if (!waiting) {
										selectChildren('.' + nameSpace + 'aiImg', el).forEach(updateImgSrc);
									}
									el.style.display = 'block';
								} else {
									el.style.display = 'none';
								}
							});

							// Initialize lazy loading on first call
							if (waiting && !observer) {
								if (elementInView(container)) {
									waiting = false;
									update();
								} else {
									observer = new IntersectionObserver(onIntersectionChange, {});
									observer.observe(container);
								}
							}
						}

						function onIntersectionChange(entries) {
							// There may be multiple entries relating to the same container
							// (captured at different times)
							var isIntersecting = entries.reduce(function (memo, entry) {
								return memo || entry.isIntersecting;
							}, false);
							if (isIntersecting) {
								waiting = false;
								// update: don't remove -- we need the observer to trigger an update
								// when a hidden map becomes visible after user interaction
								// (e.g. when an accordion menu or tab opens)
								// observer.disconnect();
								// observer = null;
								update();
							}
						}
					}

					function findContainers(id) {
						// support duplicate ids on the page
						return selectChildren('.ai2html-responsive', document).filter(function (el) {
							if (el.getAttribute('id') != id) return false;
							if (el.classList.contains('ai2html-resizer')) return false;
							el.classList.add('ai2html-resizer');
							return true;
						});
					}

					// Replace blank placeholder image with actual image
					function updateImgSrc(img) {
						var src = img.getAttribute('data-src');
						if (src && img.getAttribute('src') != src) {
							img.setAttribute('src', src);
						}
					}

					function elementInView(el) {
						var bounds = el.getBoundingClientRect();
						return bounds.top < window.innerHeight && bounds.bottom > 0;
					}

					function selectChildren(selector, parent) {
						return parent ? Array.prototype.slice.call(parent.querySelectorAll(selector)) : [];
					}

					// based on underscore.js
					function throttle(func, wait) {
						var timeout = null, previous = 0;
						function run() {
							previous = Date.now();
							timeout = null;
							func();
						}
						return function () {
							var remaining = wait - (Date.now() - previous);
							if (remaining <= 0 || remaining > wait) {
								clearTimeout(timeout);
								run();
							} else if (!timeout) {
								timeout = setTimeout(run, remaining);
							}
						};
					}
				})("g-map1-box", {namespace: "g-", setup: window.setupInteractive || window.getComponent});
		</script>
		<!-- End ai2html - 2022-08-03 00:42 -->
